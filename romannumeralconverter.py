# -*- coding: utf-8 -*-
"""RomanNumeralConverter.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gg2tfOzeLiVC1FuG-8i8d4PVUnCX-Gd2
"""

# Converting roman numerals to numbers

# Convert single letter to number
def convert(letter):
    if letter == 'I':
        return 1
    if letter == 'V':
        return 5
    if letter == 'X':
        return 10
    if letter == 'L':
        return 50
    if letter == 'C':
        return 100
    if letter == 'D':
        return 500
    if letter == 'M':
        return 1000

# Return list of numbers, given roman numeral combination
def as_number(letters):
    lst = list(letters)
    for i in range(len(lst)):
        lst[i] = convert(lst[i])
    return lst

# Return actual number, given roman numeral combination

def actual_number(letters):

  lst = as_number(letters) # Create list of numbers
  lst.append(0) # Without this, our index is out of range
  total = 0 # The final number

  # For one letter:
  if len(lst) == 1:
    return lst[0]
  
  # For multiple letters:
  # I kept track of two numbers, the current number and the next number in the
  # list. If the next number is bigger, we know we'll have to add the difference
  # between the two numbers; if it is smaller, we only the current to the total.

  counter = 0 # Keeps track of number we're adding 
  counter2 = 1 # Keeps track of next number
  while counter <= (len(lst) - 2):
    if lst[counter2] > lst[counter]:
      total += (lst[counter2] - lst[counter])
      # Update the counters
      # Skip two spots ahead, because we already used the "next" number
      counter += 2
      counter2 += 2
    else:
      total += lst[counter]
      # Update the counters
      # Skip one spot ahead, because we haven't checked the "next" number
      counter += 1
      counter2 += 1
  return total

# And now backwards.

# Convert number to letter
def to_letter(number):
    if number == 1:
        return 'I'
    if number == 5:
        return 'V'
    if number == 10:
        return 'X'
    if number == 50:
        return 'L'
    if number == 100:
        return 'C'
    if number == 500:
        return 'D'
    if number == 1000:
        return 'M'

# Return number of digits in a number
def num_digits(number):
  if number == 0:
    return 0
  return 1 + num_digits(number//10)

# Return number broken up into pieces (e.g. 989 = [900, 80, 9])
def break_up(nums):
  lst = []

  def helper(nums):
    if nums == 0:
      return
    num = nums % 10
    lst.append(num)
    helper(nums // 10)

  return helper(nums)

# Convert numbers to roman numeral
def roman_numeral(number):

  # base case 
  if to_letter(number):
    return to_letter(number)

# Unfortunately I did not finish in time. My plan was to take the number, 
# break it up into pieces (e.g. 989 = [900, 80, 9]) then break it into more 
# pieces (e.g. [900, 80, 9] = [[100, 1000], [50, 10, 10, 10], [1, 10]])
# After breaking it all up, these numbers translate perfectly to what 989 
# would be in roman numerals: CMLXXXIX (100 corresponds to C, 1000 to M, 50 
# to L and so on).